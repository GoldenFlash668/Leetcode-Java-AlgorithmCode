解法一：
根据leetcode   路径总和2   这道题，很容易想到这种解法：

上题是要求只能从根节点到叶节点，所以多加一个判断是否是叶节点的操作；
本题不需要判断是否是叶节点，只要结果是target就可以
另外题目要求只能从上到下，所以只需要访问每一个节点，对其调用修改后的  路径总和2
的方法就可以得到结果；
时间复杂度是O（n方） 空间O（N）

解法二：
相比来说，解法二的时间复杂度就小了许多，只需要进行一次遍历就可以O（N）

解法二利用了前缀和的思想；

每次访问一个点都会在MAP里记录其前缀和，只要找到一个点的   前缀和- target 在map里
而且value值大于0；就相当于找到了一个题解。

当返回上一层时只需要将这一层的延起点到这一层的val值总和，减去这个节点的val值
（在map中对应key）在map中对应的value减一即可。

解法二空间占用高一点但是也是O（N）