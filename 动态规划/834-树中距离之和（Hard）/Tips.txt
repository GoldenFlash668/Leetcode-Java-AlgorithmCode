这个题是个困难难度的题，自己做几乎没有什么思路。
但是之前做过一道关于求树中各个节点到根节点距离和的题对本题有很大的参考价值：

本题按照官方题解有两步：
在这两步之前需要将节点放到一个List图中，方便后续查找遍历。

第一步：
利用深度优先的方法遍历这个树装图；
数组dp[i]用来保存i节点到其子节点的距离和。
数组sz[i] 用来保存i节点的（子节点+本节点）个数。
这样既可以得出动态规划方程dp[j] += dp[i] + sz[i];
每个叶子节点的初始dp[i]=0 sz[i]=1;

第二步：
其实根据第一步的方法，每次遍历节点的时候都做一次第一步的操作就可以得出结果，但是这样时间复杂度就会达到O(N2)。第一步得到的有用的数据也浪费了。

所以官方题解里又进行一次dfs；
每次遍历的时候交换根节点与当前节点。让当前节点作为根节点。
假设之前根节点是u，u的一个子节点是v；
让v节点作为根节点。
之前计算的dp[u]就需要减去v节点作为子节点的贡献：dp[u]= dp[u]-(dp[v]+sz[v]);
之前计算的sz[u]就需要减去v节点作为子节点的贡献：sz[u]= sz[u]-sz[v];
新的dp[v] = dp[v]+ dp[u]+sz[u]
新的sz[v] = sz[v] + sz[u]
然后继续访问v的子节点；
注意访问完v的子节点之后要进行回溯，以方便v的兄弟节点进行相同的操作。