这道题首先想到的方法是分治法：
可以通过运算符将整个式子分成两部分，对两部分分开求解：
当被分成的两部分还不是一个单纯的数字那么就递归继续分解；（这也是递归出口）
若是一个单纯的数字就返回这个数字再与另一个数字做运算；
由于递归是两个分支，所以会有一些的解进行了重复计算，我们可以通过 memoization 技术，前边很多题都用过了，一种空间换时间的方法。

上述是我自己的思路，以下来自leetcode别人的题解，我也是利用这个思路完成动态规划解法：
按理说写完递归、 写完 memoization ，接下来动态规划也能顺理成章的写出来了，比如经典的 爬楼梯 问题。但这个如果什么都不处理，dp 数组的含义比较难定义，分享一下 这里 的处理吧。

最巧妙的地方就是做一个预处理，把每个数字提前转为 int 然后存起来，同时把运算符也都存起来。

这样的话我们就有了两个 list，一个保存了所有数字，一个保存了所有运算符。


2 * 3 - 4 * 5
存起来的数字是 numList = [2 3 4 5]，
存起来的运算符是 opList = [*, -, *]。
dp[i][j] 也比较好定义了，含义是第 i 到第 j 个数字（从 0 开始计数）范围内的表达式的所有解。


举个例子，2 * 3 - 4 * 5 
dp[1][3] 就代表第一个数字 3 到第三个数字 5 范围内的表达式 3 - 4 * 5 的所有解。
初始条件的话，也很简单了，就是范围内只有一个数字。


2 * 3 - 4 * 5 
dp[0][0] = [2]，dp[1][1] = [3]，dp[2][2] = [4]，dp[3][3] = [5]。
有了一个数字的所有解，然后两个数字的所有解就可以求出来。

有了两个数字的所有解，然后三个数字的所有解就和解法一求法一样。

把三个数字分成两部分，将两部分的解两两组合起来即可。

两部分之间的运算符的话，因为表达式是一个数字一个运算符，所以运算符的下标就是左部分最后一个数字的下标。

作者：windliang
链接：https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。