这个题一看很简单，但是自己做的总是需要两次遍历比较复杂，在看了答案之后我发现了一遍遍历的方法：
（1）由于字符串中只有数字，所以额外创建一个长度为10 的cache数组，分别代表一到十的数字；
（2）同时遍历两个字符串，当相同位置字符相同时xA++；
（3）重点是这一步：
      1，     if(cache[s-'0']++ < 0) xB++;
                if(cache[g-'0']-- > 0) xB++;
      2，cache[s-'0'] < 0 说明i位置前guess有这个字符；
           cache[g-'0'] > 0 说明i位置前secret 有这个字符；
这样就实现了一次遍历求出xA、xB两个数。感觉比用哈希表更加巧妙。