暴力法这里就不再多说；
法一：翻转整个数组，然后先反转前k个数，再反转后面的数，这个方法具体画个图就可以看出结果
法二：如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temp 里面。然后，我们将被替换数字（temp）放到它正确的位置，并继续这个过程 n 次， n 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n\%k==0，其中 k=k\%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k\%n次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。

现在，我们看看上面方法的证明。假设，数组里我们有 n 个元素并且 k 是要求移动的次数。更进一步，假设 n\%k=0 。第一轮中，所有移动数字的下标 i 满足 i\%k==0 。这是因为我们每跳 k 步，我们只会到达相距为 k 个位置下标的数。每一轮，我们都会移动n/k 个元素。下一轮中，我们会移动满足 i\%k==1 的位置的数。这样的轮次会一直持续到我们再次遇到 i\%k==0的地方为止，此时 i=k 。此时在正确位置上的数字共有k*n/k = n 个。因此所有数字都在正确位置上。
